name: Deploy Next.js site to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

  # Rebuild when the analysis workflow finishes so newly generated figures are published
  workflow_run:
    workflows: ["run-analysis"]
    types:
      - completed

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Build job
  build:
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    outputs:
      site-exists: ${{ steps.check-site.outputs.exists }}
      manifest-generated: ${{ steps.check-manifest.outputs.generated }}
    env:
      NEXT_APP_PATH: web/figures-site
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Check if Next.js site exists
        id: check-site
        run: |
          if [ -f "${{ env.NEXT_APP_PATH }}/package.json" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Next.js site detected"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No Next.js site detected"
          fi
      
      - name: Detect package manager
        if: steps.check-site.outputs.exists == 'true'
        id: detect-package-manager
        run: |
          APP_PATH="${{ env.NEXT_APP_PATH }}"
          if [ -f "$APP_PATH/yarn.lock" ]; then
            echo "manager=yarn" >> $GITHUB_OUTPUT
            echo "command=install" >> $GITHUB_OUTPUT
            echo "runner=yarn" >> $GITHUB_OUTPUT
            exit 0
          elif [ -f "$APP_PATH/package-lock.json" ]; then
            echo "manager=npm" >> $GITHUB_OUTPUT
            echo "command=ci" >> $GITHUB_OUTPUT
            echo "runner=npx --no-install" >> $GITHUB_OUTPUT
            exit 0
          elif [ -f "$APP_PATH/package.json" ]; then
            echo "manager=npm" >> $GITHUB_OUTPUT
            echo "command=install" >> $GITHUB_OUTPUT
            echo "runner=npx --no-install" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "Unable to determine package manager"
            exit 1
          fi

      - name: Restore latest analysis figures
        if: steps.check-site.outputs.exists == 'true'
        id: restore-figures
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          APP_PATH="${{ env.NEXT_APP_PATH }}"
          MANIFEST_PATH="$APP_PATH/data/figures.json"
          FIGURES_DEST="$APP_PATH/public/figures"
          mkdir -p "$(dirname "$MANIFEST_PATH")"
          mkdir -p "$APP_PATH/public"

          RUN_ID="${{ github.event.workflow_run.id || '' }}"
          if [ -z "$RUN_ID" ]; then
            RUN_ID=$(gh run list --workflow "run-analysis" --limit 20 --json databaseId,conclusion \
              --jq '.[] | select(.conclusion == "success") | .databaseId' | head -n 1 || true)
          fi

          if [ -z "$RUN_ID" ]; then
            echo "restored=false" >> "$GITHUB_OUTPUT"
            echo "No successful run-analysis workflow runs found; leaving existing manifest in place."
            exit 0
          fi

          echo "Downloading artifacts from run-analysis run $RUN_ID"
          WORK_DIR=$(mktemp -d)
          if ! gh run download "$RUN_ID" --name figure-outputs --dir "$WORK_DIR"; then
            echo "restored=false" >> "$GITHUB_OUTPUT"
            echo "Unable to download figure-outputs artifact; skipping restoration."
            exit 0
          fi

          SEARCH_ROOT="$WORK_DIR"

          ZIP_ARCHIVE=$(find "$WORK_DIR" -maxdepth 2 -type f -name '*.zip' -print -quit)
          if [ -n "$ZIP_ARCHIVE" ]; then
            echo "Extracting artifact archive $ZIP_ARCHIVE"
            EXTRACT_DIR=$(mktemp -d)
            if unzip -q "$ZIP_ARCHIVE" -d "$EXTRACT_DIR"; then
              SEARCH_ROOT="$EXTRACT_DIR"
            else
              echo "Warning: failed to extract $ZIP_ARCHIVE; continuing with downloaded directory structure."
            fi
          fi

          FIGURES_ROOT=$(find "$SEARCH_ROOT" -type d -path "*/artifacts/figures" -print -quit)
          if [ -z "$FIGURES_ROOT" ]; then
            FIGURES_ROOT=$(find "$SEARCH_ROOT" -maxdepth 8 -type d -name figures -print -quit)
          fi

          if [ -z "$FIGURES_ROOT" ]; then
            export SEARCH_ROOT
            FIGURES_ROOT=$(python3 - <<'PY'
import os
from pathlib import Path

ALLOWED = {".png", ".pdf", ".svg"}
search_root = Path(os.environ["SEARCH_ROOT"])
figure_files = []

for path in search_root.rglob("*"):
    if path.is_file() and path.suffix.lower() in ALLOWED:
        figure_files.append(path)
        if len(figure_files) > 512:
            break

if figure_files:
    def find_named_figures_root(path: Path):
        for parent in path.parents:
            if parent.name == "figures":
                return parent
        return None

    chosen = None
    for fig in figure_files:
        chosen = find_named_figures_root(fig)
        if chosen:
            break

    if not chosen:
        common = Path(os.path.commonpath([str(p.parent) for p in figure_files]))
        chosen = common

    print(chosen.as_posix())
PY
)
          fi

          if [ -z "$FIGURES_ROOT" ]; then
            echo "Figures directory not found in artifact; generating empty manifest."
            FIGURES_ROOT=$(mktemp -d)
          else
            echo "Using figures root: $FIGURES_ROOT"
          fi

          python3 scripts/prepare_figures_manifest.py \
            --figures-root "$FIGURES_ROOT" \
            --public-root "$FIGURES_DEST" \
            --manifest-path "$MANIFEST_PATH"

          echo "restored=true" >> "$GITHUB_OUTPUT"
          echo "Manifest and figures restored from run-analysis artifacts."

      - name: Check manifest status
        if: steps.check-site.outputs.exists == 'true'
        id: check-manifest
        run: |
          set -euo pipefail
          APP_PATH="${{ env.NEXT_APP_PATH }}"
          MANIFEST="$APP_PATH/data/figures.json"

          if [ ! -f "$MANIFEST" ]; then
            echo "generated=false" >> "$GITHUB_OUTPUT"
            echo "Manifest not found at $MANIFEST; skipping deployment."
            exit 0
          fi

          export MANIFEST
          GENERATED=$(python3 - <<'PY'
          import json
          import os

          path = os.environ["MANIFEST"]
          with open(path, "r", encoding="utf-8") as fh:
              data = json.load(fh)

          print("true" if data.get("generatedAt") else "false")
          PY
          )

          echo "generated=$GENERATED" >> "$GITHUB_OUTPUT"

          if [ "$GENERATED" != "true" ]; then
            echo "Manifest is missing a generatedAt timestamp; skipping deployment."
          fi

      - name: Setup Node
        if: steps.check-site.outputs.exists == 'true' && steps.check-manifest.outputs.generated == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: ${{ steps.detect-package-manager.outputs.manager }}
          cache-dependency-path: ${{ env.NEXT_APP_PATH }}/${{ steps.detect-package-manager.outputs.manager == 'yarn' && 'yarn.lock' || 'package-lock.json' }}

      - name: Setup Pages
        if: steps.check-site.outputs.exists == 'true' && steps.check-manifest.outputs.generated == 'true'
        uses: actions/configure-pages@v5
        with:
          static_site_generator: next

      - name: Restore cache
        if: steps.check-site.outputs.exists == 'true' && steps.check-manifest.outputs.generated == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.NEXT_APP_PATH }}/.next/cache
          key: ${{ runner.os }}-nextjs-${{ hashFiles('web/figures-site/package-lock.json', 'web/figures-site/yarn.lock') }}-${{ hashFiles('web/figures-site/**/*.[jt]s', 'web/figures-site/**/*.[jt]sx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('web/figures-site/package-lock.json', 'web/figures-site/yarn.lock') }}-

      - name: Install dependencies
        if: steps.check-site.outputs.exists == 'true' && steps.check-manifest.outputs.generated == 'true'
        working-directory: ${{ env.NEXT_APP_PATH }}
        run: ${{ steps.detect-package-manager.outputs.manager }} ${{ steps.detect-package-manager.outputs.command }}

      - name: Build with Next.js
        if: steps.check-site.outputs.exists == 'true' && steps.check-manifest.outputs.generated == 'true'
        working-directory: ${{ env.NEXT_APP_PATH }}
        run: ${{ steps.detect-package-manager.outputs.runner }} next build

      - name: Upload artifact
        if: steps.check-site.outputs.exists == 'true' && steps.check-manifest.outputs.generated == 'true'
        uses: actions/upload-pages-artifact@v3
        with:
          path: ${{ env.NEXT_APP_PATH }}/out

  # Deployment job
  deploy:
    if: needs.build.outputs.site-exists == 'true' && needs.build.outputs.manifest-generated == 'true'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
